{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { useRef, useState } from 'react';\nimport { ActivityIndicator, StyleSheet, View } from 'react-native'; // import { FlatList } from '@stream-io/flat-list-mvcp';\n\nconst styles = StyleSheet.create({\n  indicatorContainer: {\n    paddingVertical: 5,\n    width: '100%'\n  }\n});\n/**\n * Note:\n * - `onEndReached` and `onStartReached` must return a promise.\n * - `onEndReached` and `onStartReached` only get called once, per content length.\n * - maintainVisibleContentPosition is fixed, and can't be modified through props.\n * - doesn't accept `ListFooterComponent` via prop, since it is occupied by `FooterLoadingIndicator`.\n *    Set `showDefaultLoadingIndicators` to use `ListFooterComponent`.\n * - doesn't accept `ListHeaderComponent` via prop, since it is occupied by `HeaderLoadingIndicator`\n *    Set `showDefaultLoadingIndicators` to use `ListHeaderComponent`.\n */\n\nexport const BidirectionalFlatList = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    activityIndicatorColor = 'black',\n    autoscrollToTopThreshold = 100,\n    data,\n    enableAutoscrollToTop,\n    FooterLoadingIndicator,\n    HeaderLoadingIndicator,\n    ListHeaderComponent,\n    ListFooterComponent,\n    onEndReached = () => Promise.resolve(),\n    onEndReachedThreshold = 10,\n    onScroll,\n    onStartReached = () => Promise.resolve(),\n    onStartReachedThreshold = 10,\n    showDefaultLoadingIndicators = true\n  } = props;\n  const [onStartReachedInProgress, setOnStartReachedInProgress] = useState(false);\n  const [onEndReachedInProgress, setOnEndReachedInProgress] = useState(false);\n  const onStartReachedTracker = useRef({});\n  const onEndReachedTracker = useRef({});\n  const onStartReachedInPromise = useRef(null);\n  const onEndReachedInPromise = useRef(null);\n\n  const maybeCallOnStartReached = () => {\n    // If onStartReached has already been called for given data length, then ignore.\n    if (data !== null && data !== void 0 && data.length && onStartReachedTracker.current[data.length]) {\n      return;\n    }\n\n    if (data !== null && data !== void 0 && data.length) {\n      onStartReachedTracker.current[data.length] = true;\n    }\n\n    setOnStartReachedInProgress(true);\n\n    const p = () => {\n      return new Promise(resolve => {\n        onStartReachedInPromise.current = null;\n        setOnStartReachedInProgress(false);\n        resolve();\n      });\n    };\n\n    if (onEndReachedInPromise.current) {\n      onEndReachedInPromise.current.finally(() => {\n        onStartReachedInPromise.current = onStartReached().then(p);\n      });\n    } else {\n      onStartReachedInPromise.current = onStartReached().then(p);\n    }\n  };\n\n  const maybeCallOnEndReached = () => {\n    // If onEndReached has already been called for given data length, then ignore.\n    if (data !== null && data !== void 0 && data.length && onEndReachedTracker.current[data.length]) {\n      return;\n    }\n\n    if (data !== null && data !== void 0 && data.length) {\n      onEndReachedTracker.current[data.length] = true;\n    }\n\n    setOnEndReachedInProgress(true);\n\n    const p = () => {\n      return new Promise(resolve => {\n        onStartReachedInPromise.current = null;\n        setOnEndReachedInProgress(false);\n        resolve();\n      });\n    };\n\n    if (onStartReachedInPromise.current) {\n      onStartReachedInPromise.current.finally(() => {\n        onEndReachedInPromise.current = onEndReached().then(p);\n      });\n    } else {\n      onEndReachedInPromise.current = onEndReached().then(p);\n    }\n  };\n\n  const handleScroll = event => {\n    // Call the parent onScroll handler, if provided.\n    onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);\n    const offset = event.nativeEvent.contentOffset.y;\n    const visibleLength = event.nativeEvent.layoutMeasurement.height;\n    const contentLength = event.nativeEvent.contentSize.height; // Check if scroll has reached either start of end of list.\n\n    const isScrollAtStart = offset < onStartReachedThreshold;\n    const isScrollAtEnd = contentLength - visibleLength - offset < onEndReachedThreshold;\n\n    if (isScrollAtStart) {\n      maybeCallOnStartReached();\n    }\n\n    if (isScrollAtEnd) {\n      maybeCallOnEndReached();\n    }\n  };\n\n  const renderHeaderLoadingIndicator = () => {\n    if (!showDefaultLoadingIndicators) {\n      if (ListHeaderComponent) {\n        return /*#__PURE__*/React.createElement(ListHeaderComponent, null);\n      } else {\n        return null;\n      }\n    }\n\n    if (!onStartReachedInProgress) return null;\n\n    if (HeaderLoadingIndicator) {\n      return /*#__PURE__*/React.createElement(HeaderLoadingIndicator, null);\n    }\n\n    return /*#__PURE__*/React.createElement(View, {\n      style: styles.indicatorContainer\n    }, /*#__PURE__*/React.createElement(ActivityIndicator, {\n      size: 'small',\n      color: activityIndicatorColor\n    }));\n  };\n\n  const renderFooterLoadingIndicator = () => {\n    if (!showDefaultLoadingIndicators) {\n      if (ListFooterComponent) {\n        return /*#__PURE__*/React.createElement(ListFooterComponent, null);\n      } else {\n        return null;\n      }\n    }\n\n    if (!onEndReachedInProgress) return null;\n\n    if (FooterLoadingIndicator) {\n      return /*#__PURE__*/React.createElement(FooterLoadingIndicator, null);\n    }\n\n    return /*#__PURE__*/React.createElement(View, {\n      style: styles.indicatorContainer\n    }, /*#__PURE__*/React.createElement(ActivityIndicator, {\n      size: 'small',\n      color: activityIndicatorColor\n    }));\n  };\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FlatList, _extends({}, props, {\n    ref: ref,\n    progressViewOffset: 50,\n    ListHeaderComponent: renderHeaderLoadingIndicator,\n    ListFooterComponent: renderFooterLoadingIndicator,\n    onEndReached: null,\n    onScroll: handleScroll,\n    maintainVisibleContentPosition: {\n      autoscrollToTopThreshold: enableAutoscrollToTop ? autoscrollToTopThreshold : undefined,\n      minIndexForVisible: 1\n    }\n  })));\n});","map":{"version":3,"sources":["BidirectionalFlatList.tsx"],"names":["styles","indicatorContainer","paddingVertical","width","BidirectionalFlatList","activityIndicatorColor","autoscrollToTopThreshold","onEndReached","Promise","onEndReachedThreshold","onStartReached","onStartReachedThreshold","showDefaultLoadingIndicators","useState","onStartReachedTracker","useRef","onEndReachedTracker","onStartReachedInPromise","onEndReachedInPromise","maybeCallOnStartReached","data","setOnStartReachedInProgress","p","resolve","maybeCallOnEndReached","setOnEndReachedInProgress","handleScroll","event","onScroll","offset","visibleLength","contentLength","isScrollAtStart","isScrollAtEnd","renderHeaderLoadingIndicator","renderFooterLoadingIndicator","enableAutoscrollToTop","minIndexForVisible"],"mappings":"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","sourcesContent":["import React, { MutableRefObject, useRef, useState } from 'react';\nimport {\n  ActivityIndicator,\n  FlatList as FlatListType,\n  FlatListProps,\n  ScrollViewProps,\n  StyleSheet,\n  View,\n} from 'react-native';\nimport { FlatList } from '@stream-io/flat-list-mvcp';\n\nconst styles = StyleSheet.create({\n  indicatorContainer: {\n    paddingVertical: 5,\n    width: '100%',\n  },\n});\n\nexport type Props<T> = Omit<\n  FlatListProps<T>,\n  'maintainVisibleContentPosition'\n> & {\n  /**\n   * Called once when the scroll position gets close to end of list. This must return a promise.\n   * You can `onEndReachedThreshold` as distance from end of list, when this function should be called.\n   */\n  onEndReached: () => Promise<void>;\n  /**\n   * Called once when the scroll position gets close to begining of list. This must return a promise.\n   * You can `onStartReachedThreshold` as distance from beginning of list, when this function should be called.\n   */\n  onStartReached: () => Promise<void>;\n  /** Color for inline loading indicator */\n  activityIndicatorColor?: string;\n  /**\n   * Enable autoScrollToTop.\n   * In chat type applications, you want to auto scroll to bottom, when new message comes it.\n   */\n  enableAutoscrollToTop?: boolean;\n  /**\n   * If `enableAutoscrollToTop` is true, the scroll threshold below which auto scrolling should occur.\n   */\n  autoscrollToTopThreshold?: number;\n  /** Scroll distance from beginning of list, when onStartReached should be called. */\n  onStartReachedThreshold?: number;\n  /**\n   * Scroll distance from end of list, when onStartReached should be called.\n   * Please note that this is different from onEndReachedThreshold of FlatList from react-native.\n   */\n  onEndReachedThreshold?: number;\n  /** If true, inline loading indicators will be shown. Default - true */\n  showDefaultLoadingIndicators?: boolean;\n  /** Custom UI component for header inline loading indicator */\n  HeaderLoadingIndicator?: React.ComponentType;\n  /** Custom UI component for footer inline loading indicator */\n  FooterLoadingIndicator?: React.ComponentType;\n  /** Custom UI component for header indicator of FlatList. Only used when `showDefaultLoadingIndicators` is false */\n  ListHeaderComponent?: React.ComponentType;\n  /** Custom UI component for footer indicator of FlatList. Only used when `showDefaultLoadingIndicators` is false */\n  ListFooterComponent?: React.ComponentType;\n};\n/**\n * Note:\n * - `onEndReached` and `onStartReached` must return a promise.\n * - `onEndReached` and `onStartReached` only get called once, per content length.\n * - maintainVisibleContentPosition is fixed, and can't be modified through props.\n * - doesn't accept `ListFooterComponent` via prop, since it is occupied by `FooterLoadingIndicator`.\n *    Set `showDefaultLoadingIndicators` to use `ListFooterComponent`.\n * - doesn't accept `ListHeaderComponent` via prop, since it is occupied by `HeaderLoadingIndicator`\n *    Set `showDefaultLoadingIndicators` to use `ListHeaderComponent`.\n */\nexport const BidirectionalFlatList = (React.forwardRef(\n  <T extends any>(\n    props: Props<T>,\n    ref:\n      | ((instance: FlatListType<T> | null) => void)\n      | MutableRefObject<FlatListType<T> | null>\n      | null\n  ) => {\n    const {\n      activityIndicatorColor = 'black',\n      autoscrollToTopThreshold = 100,\n      data,\n      enableAutoscrollToTop,\n      FooterLoadingIndicator,\n      HeaderLoadingIndicator,\n      ListHeaderComponent,\n      ListFooterComponent,\n      onEndReached = () => Promise.resolve(),\n      onEndReachedThreshold = 10,\n      onScroll,\n      onStartReached = () => Promise.resolve(),\n      onStartReachedThreshold = 10,\n      showDefaultLoadingIndicators = true,\n    } = props;\n    const [onStartReachedInProgress, setOnStartReachedInProgress] = useState(\n      false\n    );\n    const [onEndReachedInProgress, setOnEndReachedInProgress] = useState(false);\n\n    const onStartReachedTracker = useRef<Record<number, boolean>>({});\n    const onEndReachedTracker = useRef<Record<number, boolean>>({});\n\n    const onStartReachedInPromise = useRef<Promise<void> | null>(null);\n    const onEndReachedInPromise = useRef<Promise<void> | null>(null);\n\n    const maybeCallOnStartReached = () => {\n      // If onStartReached has already been called for given data length, then ignore.\n      if (data?.length && onStartReachedTracker.current[data.length]) {\n        return;\n      }\n\n      if (data?.length) {\n        onStartReachedTracker.current[data.length] = true;\n      }\n\n      setOnStartReachedInProgress(true);\n      const p = () => {\n        return new Promise<void>((resolve) => {\n          onStartReachedInPromise.current = null;\n          setOnStartReachedInProgress(false);\n          resolve();\n        });\n      };\n\n      if (onEndReachedInPromise.current) {\n        onEndReachedInPromise.current.finally(() => {\n          onStartReachedInPromise.current = onStartReached().then(p);\n        });\n      } else {\n        onStartReachedInPromise.current = onStartReached().then(p);\n      }\n    };\n\n    const maybeCallOnEndReached = () => {\n      // If onEndReached has already been called for given data length, then ignore.\n      if (data?.length && onEndReachedTracker.current[data.length]) {\n        return;\n      }\n\n      if (data?.length) {\n        onEndReachedTracker.current[data.length] = true;\n      }\n\n      setOnEndReachedInProgress(true);\n      const p = () => {\n        return new Promise<void>((resolve) => {\n          onStartReachedInPromise.current = null;\n          setOnEndReachedInProgress(false);\n          resolve();\n        });\n      };\n\n      if (onStartReachedInPromise.current) {\n        onStartReachedInPromise.current.finally(() => {\n          onEndReachedInPromise.current = onEndReached().then(p);\n        });\n      } else {\n        onEndReachedInPromise.current = onEndReached().then(p);\n      }\n    };\n\n    const handleScroll: ScrollViewProps['onScroll'] = (event) => {\n      // Call the parent onScroll handler, if provided.\n      onScroll?.(event);\n\n      const offset = event.nativeEvent.contentOffset.y;\n      const visibleLength = event.nativeEvent.layoutMeasurement.height;\n      const contentLength = event.nativeEvent.contentSize.height;\n\n      // Check if scroll has reached either start of end of list.\n      const isScrollAtStart = offset < onStartReachedThreshold;\n      const isScrollAtEnd =\n        contentLength - visibleLength - offset < onEndReachedThreshold;\n\n      if (isScrollAtStart) {\n        maybeCallOnStartReached();\n      }\n\n      if (isScrollAtEnd) {\n        maybeCallOnEndReached();\n      }\n    };\n\n    const renderHeaderLoadingIndicator = () => {\n      if (!showDefaultLoadingIndicators) {\n        if (ListHeaderComponent) {\n          return <ListHeaderComponent />;\n        } else {\n          return null;\n        }\n      }\n\n      if (!onStartReachedInProgress) return null;\n\n      if (HeaderLoadingIndicator) {\n        return <HeaderLoadingIndicator />;\n      }\n\n      return (\n        <View style={styles.indicatorContainer}>\n          <ActivityIndicator size={'small'} color={activityIndicatorColor} />\n        </View>\n      );\n    };\n\n    const renderFooterLoadingIndicator = () => {\n      if (!showDefaultLoadingIndicators) {\n        if (ListFooterComponent) {\n          return <ListFooterComponent />;\n        } else {\n          return null;\n        }\n      }\n\n      if (!onEndReachedInProgress) return null;\n\n      if (FooterLoadingIndicator) {\n        return <FooterLoadingIndicator />;\n      }\n\n      return (\n        <View style={styles.indicatorContainer}>\n          <ActivityIndicator size={'small'} color={activityIndicatorColor} />\n        </View>\n      );\n    };\n\n    return (\n      <>\n        <FlatList<T>\n          {...props}\n          ref={ref}\n          progressViewOffset={50}\n          ListHeaderComponent={renderHeaderLoadingIndicator}\n          ListFooterComponent={renderFooterLoadingIndicator}\n          onEndReached={null}\n          onScroll={handleScroll}\n          maintainVisibleContentPosition={{\n            autoscrollToTopThreshold: enableAutoscrollToTop\n              ? autoscrollToTopThreshold\n              : undefined,\n            minIndexForVisible: 1,\n          }}\n        />\n      </>\n    );\n  }\n) as unknown) as BidirectionalFlatListType;\n\ntype BidirectionalFlatListType = <T extends any>(\n  props: Props<T>\n) => React.ReactElement;\n"]},"metadata":{},"sourceType":"module"}