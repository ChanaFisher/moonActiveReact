{"ast":null,"code":"// function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n// import React, { useRef, useState } from 'react';\n// import { ActivityIndicator, StyleSheet, View } from 'react-native';\n// // import { FlatList } from '@stream-io/flat-list-mvcp';\n// const styles = StyleSheet.create({\n//   indicatorContainer: {\n//     paddingVertical: 5,\n//     width: '100%'\n//   }\n// });\n// /**\n//  * Note:\n//  * - `onEndReached` and `onStartReached` must return a promise.\n//  * - `onEndReached` and `onStartReached` only get called once, per content length.\n//  * - maintainVisibleContentPosition is fixed, and can't be modified through props.\n//  * - doesn't accept `ListFooterComponent` via prop, since it is occupied by `FooterLoadingIndicator`.\n//  *    Set `showDefaultLoadingIndicators` to use `ListFooterComponent`.\n//  * - doesn't accept `ListHeaderComponent` via prop, since it is occupied by `HeaderLoadingIndicator`\n//  *    Set `showDefaultLoadingIndicators` to use `ListHeaderComponent`.\n//  */\n// export const BidirectionalFlatList = /*#__PURE__*/React.forwardRef((props, ref) => {\n//   const {\n//     activityIndicatorColor = 'black',\n//     autoscrollToTopThreshold = 100,\n//     data,\n//     enableAutoscrollToTop,\n//     FooterLoadingIndicator,\n//     HeaderLoadingIndicator,\n//     ListHeaderComponent,\n//     ListFooterComponent,\n//     onEndReached = () => Promise.resolve(),\n//     onEndReachedThreshold = 10,\n//     onScroll,\n//     onStartReached = () => Promise.resolve(),\n//     onStartReachedThreshold = 10,\n//     showDefaultLoadingIndicators = true\n//   } = props;\n//   const [onStartReachedInProgress, setOnStartReachedInProgress] = useState(false);\n//   const [onEndReachedInProgress, setOnEndReachedInProgress] = useState(false);\n//   const onStartReachedTracker = useRef({});\n//   const onEndReachedTracker = useRef({});\n//   const onStartReachedInPromise = useRef(null);\n//   const onEndReachedInPromise = useRef(null);\n//   const maybeCallOnStartReached = () => {\n//     // If onStartReached has already been called for given data length, then ignore.\n//     if (data !== null && data !== void 0 && data.length && onStartReachedTracker.current[data.length]) {\n//       return;\n//     }\n//     if (data !== null && data !== void 0 && data.length) {\n//       onStartReachedTracker.current[data.length] = true;\n//     }\n//     setOnStartReachedInProgress(true);\n//     const p = () => {\n//       return new Promise(resolve => {\n//         onStartReachedInPromise.current = null;\n//         setOnStartReachedInProgress(false);\n//         resolve();\n//       });\n//     };\n//     if (onEndReachedInPromise.current) {\n//       onEndReachedInPromise.current.finally(() => {\n//         onStartReachedInPromise.current = onStartReached().then(p);\n//       });\n//     } else {\n//       onStartReachedInPromise.current = onStartReached().then(p);\n//     }\n//   };\n//   const maybeCallOnEndReached = () => {\n//     // If onEndReached has already been called for given data length, then ignore.\n//     if (data !== null && data !== void 0 && data.length && onEndReachedTracker.current[data.length]) {\n//       return;\n//     }\n//     if (data !== null && data !== void 0 && data.length) {\n//       onEndReachedTracker.current[data.length] = true;\n//     }\n//     setOnEndReachedInProgress(true);\n//     const p = () => {\n//       return new Promise(resolve => {\n//         onStartReachedInPromise.current = null;\n//         setOnEndReachedInProgress(false);\n//         resolve();\n//       });\n//     };\n//     if (onStartReachedInPromise.current) {\n//       onStartReachedInPromise.current.finally(() => {\n//         onEndReachedInPromise.current = onEndReached().then(p);\n//       });\n//     } else {\n//       onEndReachedInPromise.current = onEndReached().then(p);\n//     }\n//   };\n//   const handleScroll = event => {\n//     // Call the parent onScroll handler, if provided.\n//     onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);\n//     const offset = event.nativeEvent.contentOffset.y;\n//     const visibleLength = event.nativeEvent.layoutMeasurement.height;\n//     const contentLength = event.nativeEvent.contentSize.height; // Check if scroll has reached either start of end of list.\n//     const isScrollAtStart = offset < onStartReachedThreshold;\n//     const isScrollAtEnd = contentLength - visibleLength - offset < onEndReachedThreshold;\n//     if (isScrollAtStart) {\n//       maybeCallOnStartReached();\n//     }\n//     if (isScrollAtEnd) {\n//       maybeCallOnEndReached();\n//     }\n//   };\n//   const renderHeaderLoadingIndicator = () => {\n//     if (!showDefaultLoadingIndicators) {\n//       if (ListHeaderComponent) {\n//         return /*#__PURE__*/React.createElement(ListHeaderComponent, null);\n//       } else {\n//         return null;\n//       }\n//     }\n//     if (!onStartReachedInProgress) return null;\n//     if (HeaderLoadingIndicator) {\n//       return /*#__PURE__*/React.createElement(HeaderLoadingIndicator, null);\n//     }\n//     return /*#__PURE__*/React.createElement(View, {\n//       style: styles.indicatorContainer\n//     }, /*#__PURE__*/React.createElement(ActivityIndicator, {\n//       size: 'small',\n//       color: activityIndicatorColor\n//     }));\n//   };\n//   const renderFooterLoadingIndicator = () => {\n//     if (!showDefaultLoadingIndicators) {\n//       if (ListFooterComponent) {\n//         return /*#__PURE__*/React.createElement(ListFooterComponent, null);\n//       } else {\n//         return null;\n//       }\n//     }\n//     if (!onEndReachedInProgress) return null;\n//     if (FooterLoadingIndicator) {\n//       return /*#__PURE__*/React.createElement(FooterLoadingIndicator, null);\n//     }\n//     return /*#__PURE__*/React.createElement(View, {\n//       style: styles.indicatorContainer\n//     }, /*#__PURE__*/React.createElement(ActivityIndicator, {\n//       size: 'small',\n//       color: activityIndicatorColor\n//     }));\n//   };\n//   return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FlatList, _extends({}, props, {\n//     ref: ref,\n//     progressViewOffset: 50,\n//     ListHeaderComponent: renderHeaderLoadingIndicator,\n//     ListFooterComponent: renderFooterLoadingIndicator,\n//     onEndReached: null,\n//     onScroll: handleScroll,\n//     maintainVisibleContentPosition: {\n//       autoscrollToTopThreshold: enableAutoscrollToTop ? autoscrollToTopThreshold : undefined,\n//       minIndexForVisible: 1\n//     }\n//   })));\n// });\n// //# sourceMappingURL=BidirectionalFlatList.js.map","map":{"version":3,"sources":["C:/Users/אתרא/Desktop/LeaderFinalProject-master/react/node_modules/react-native-bidirectional-infinite-scroll/lib/module/BidirectionalFlatList.js"],"names":[],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// import React, { useRef, useState } from 'react';\n// import { ActivityIndicator, StyleSheet, View } from 'react-native';\n// // import { FlatList } from '@stream-io/flat-list-mvcp';\n// const styles = StyleSheet.create({\n//   indicatorContainer: {\n//     paddingVertical: 5,\n//     width: '100%'\n//   }\n// });\n\n// /**\n//  * Note:\n//  * - `onEndReached` and `onStartReached` must return a promise.\n//  * - `onEndReached` and `onStartReached` only get called once, per content length.\n//  * - maintainVisibleContentPosition is fixed, and can't be modified through props.\n//  * - doesn't accept `ListFooterComponent` via prop, since it is occupied by `FooterLoadingIndicator`.\n//  *    Set `showDefaultLoadingIndicators` to use `ListFooterComponent`.\n//  * - doesn't accept `ListHeaderComponent` via prop, since it is occupied by `HeaderLoadingIndicator`\n//  *    Set `showDefaultLoadingIndicators` to use `ListHeaderComponent`.\n//  */\n// export const BidirectionalFlatList = /*#__PURE__*/React.forwardRef((props, ref) => {\n//   const {\n//     activityIndicatorColor = 'black',\n//     autoscrollToTopThreshold = 100,\n//     data,\n//     enableAutoscrollToTop,\n//     FooterLoadingIndicator,\n//     HeaderLoadingIndicator,\n//     ListHeaderComponent,\n//     ListFooterComponent,\n//     onEndReached = () => Promise.resolve(),\n//     onEndReachedThreshold = 10,\n//     onScroll,\n//     onStartReached = () => Promise.resolve(),\n//     onStartReachedThreshold = 10,\n//     showDefaultLoadingIndicators = true\n//   } = props;\n//   const [onStartReachedInProgress, setOnStartReachedInProgress] = useState(false);\n//   const [onEndReachedInProgress, setOnEndReachedInProgress] = useState(false);\n//   const onStartReachedTracker = useRef({});\n//   const onEndReachedTracker = useRef({});\n//   const onStartReachedInPromise = useRef(null);\n//   const onEndReachedInPromise = useRef(null);\n\n//   const maybeCallOnStartReached = () => {\n//     // If onStartReached has already been called for given data length, then ignore.\n//     if (data !== null && data !== void 0 && data.length && onStartReachedTracker.current[data.length]) {\n//       return;\n//     }\n\n//     if (data !== null && data !== void 0 && data.length) {\n//       onStartReachedTracker.current[data.length] = true;\n//     }\n\n//     setOnStartReachedInProgress(true);\n\n//     const p = () => {\n//       return new Promise(resolve => {\n//         onStartReachedInPromise.current = null;\n//         setOnStartReachedInProgress(false);\n//         resolve();\n//       });\n//     };\n\n//     if (onEndReachedInPromise.current) {\n//       onEndReachedInPromise.current.finally(() => {\n//         onStartReachedInPromise.current = onStartReached().then(p);\n//       });\n//     } else {\n//       onStartReachedInPromise.current = onStartReached().then(p);\n//     }\n//   };\n\n//   const maybeCallOnEndReached = () => {\n//     // If onEndReached has already been called for given data length, then ignore.\n//     if (data !== null && data !== void 0 && data.length && onEndReachedTracker.current[data.length]) {\n//       return;\n//     }\n\n//     if (data !== null && data !== void 0 && data.length) {\n//       onEndReachedTracker.current[data.length] = true;\n//     }\n\n//     setOnEndReachedInProgress(true);\n\n//     const p = () => {\n//       return new Promise(resolve => {\n//         onStartReachedInPromise.current = null;\n//         setOnEndReachedInProgress(false);\n//         resolve();\n//       });\n//     };\n\n//     if (onStartReachedInPromise.current) {\n//       onStartReachedInPromise.current.finally(() => {\n//         onEndReachedInPromise.current = onEndReached().then(p);\n//       });\n//     } else {\n//       onEndReachedInPromise.current = onEndReached().then(p);\n//     }\n//   };\n\n//   const handleScroll = event => {\n//     // Call the parent onScroll handler, if provided.\n//     onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);\n//     const offset = event.nativeEvent.contentOffset.y;\n//     const visibleLength = event.nativeEvent.layoutMeasurement.height;\n//     const contentLength = event.nativeEvent.contentSize.height; // Check if scroll has reached either start of end of list.\n\n//     const isScrollAtStart = offset < onStartReachedThreshold;\n//     const isScrollAtEnd = contentLength - visibleLength - offset < onEndReachedThreshold;\n\n//     if (isScrollAtStart) {\n//       maybeCallOnStartReached();\n//     }\n\n//     if (isScrollAtEnd) {\n//       maybeCallOnEndReached();\n//     }\n//   };\n\n//   const renderHeaderLoadingIndicator = () => {\n//     if (!showDefaultLoadingIndicators) {\n//       if (ListHeaderComponent) {\n//         return /*#__PURE__*/React.createElement(ListHeaderComponent, null);\n//       } else {\n//         return null;\n//       }\n//     }\n\n//     if (!onStartReachedInProgress) return null;\n\n//     if (HeaderLoadingIndicator) {\n//       return /*#__PURE__*/React.createElement(HeaderLoadingIndicator, null);\n//     }\n\n//     return /*#__PURE__*/React.createElement(View, {\n//       style: styles.indicatorContainer\n//     }, /*#__PURE__*/React.createElement(ActivityIndicator, {\n//       size: 'small',\n//       color: activityIndicatorColor\n//     }));\n//   };\n\n//   const renderFooterLoadingIndicator = () => {\n//     if (!showDefaultLoadingIndicators) {\n//       if (ListFooterComponent) {\n//         return /*#__PURE__*/React.createElement(ListFooterComponent, null);\n//       } else {\n//         return null;\n//       }\n//     }\n\n//     if (!onEndReachedInProgress) return null;\n\n//     if (FooterLoadingIndicator) {\n//       return /*#__PURE__*/React.createElement(FooterLoadingIndicator, null);\n//     }\n\n//     return /*#__PURE__*/React.createElement(View, {\n//       style: styles.indicatorContainer\n//     }, /*#__PURE__*/React.createElement(ActivityIndicator, {\n//       size: 'small',\n//       color: activityIndicatorColor\n//     }));\n//   };\n\n//   return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FlatList, _extends({}, props, {\n//     ref: ref,\n//     progressViewOffset: 50,\n//     ListHeaderComponent: renderHeaderLoadingIndicator,\n//     ListFooterComponent: renderFooterLoadingIndicator,\n//     onEndReached: null,\n//     onScroll: handleScroll,\n//     maintainVisibleContentPosition: {\n//       autoscrollToTopThreshold: enableAutoscrollToTop ? autoscrollToTopThreshold : undefined,\n//       minIndexForVisible: 1\n//     }\n//   })));\n// });\n// //# sourceMappingURL=BidirectionalFlatList.js.map"]},"metadata":{},"sourceType":"script"}